In this practice, we will be using sqlc to generate a database layer for our application. We have to define the schema and queries for our database. We will be using sqlc to generate a database layer for our application. We have to define the schema and queries for our database.

Here is what sqlc.yaml will look like -

```
version: "2"
sql:
  - engine: "postgresql"
    queries: "./query/*sql"
    schema: "./db/migrations"
    gen:
      go:
        package: "db"
        out: "./db"
        emit_json_tags: true
```

The sqlc tool reads these .sql files and generates Go code that provides type-safe and convenient ways to execute these queries against your database. For each named query in your SQL files, sqlc will generate a corresponding Go function within the db package (or whatever package name you configured).

In our queries file we have to add the comment on top of our query. This name becomes the name of the function that sqlc generates. :one means it should return one row. For multiple rows it should be :many

```
-- name: GetUser :one
select id,username,email from users where id = $1;
```

After creating sql scripts(schema and queries) and creating sqlc.yaml file, we can use below command to generate the code for us. We should run this command from the folder where yaml file is cretaed. Root folder

```
sqlc generate
```

For Db migration we are using goose.

```
-- +goose Up
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL,
  password VARCHAR(255) NOT NULL
);

-- +goose Down
drop table users;
```

Command to run postgres locally using docker

```
docker run --name some-postgres -e POSTGRES_USER=sanchit -e POSTGRES_PASSWORD=password -e POSTGRES_DB=testdatabase -p 5432:5432 -d postgres
```

we need to use these comments in our migration file. After creating this we need to use below command to do the migration from the folder where migration file is created.

```

// for migrating up
goose postgres "postgresql://sanchit:password@localhost:5432/testdatabase?sslmode=disable" up 


// for migrating down
goose postgres "postgresql://sanchit:password@localhost:5432/testdatabase?sslmode=disable" down


```

In connection.go file we are creating the database connection and queries, this queries is type (struct) which is created by sqlc code which has db as one of the parameter, we create the db connection and create the Queries struct using the New method created by sqlc. This db is the database connection that we create. Queries struct implements all the methods that we have defined in our sql files, which are generated by sqlc. We are exporting both db connection and queries reference from the method getDb and these will be used from other places/packages.

```
package db

import (
	"database/sql"
	"log"

	_ "github.com/lib/pq"
)

var db *sql.DB
var queries *Queries

func InitDb() {
	var err error
	db, err = sql.Open("postgres", "postgresql://sanchit:password@localhost:5432/yourdatabase?sslmode=disable")
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	}
	if err = db.Ping(); err != nil {
		log.Fatalf("Failed to ping the database: %v", err)
	}
	queries = New(db)
}

func GetDB() (*sql.DB, *Queries) {
	return db, queries
}

```

below is generated by sqlc

```
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

```
